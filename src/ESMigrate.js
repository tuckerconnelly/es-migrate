/* eslint-disable max-len */

const path = require('path')
const fs = require('fs')

const minimist = require('minimist')

function zeroPad(number, length) {
  const stringNumber = '' + number
  if (stringNumber.length === length) return number
  return zeroPad(`0${number}`, length)
}

function tsFromVersion(version) {
  const year = version.substr(0, 4)
  const month = version.substr(4, 2)
  const date = version.substr(6, 2)
  const hours = version.substr(8, 2)
  const minutes = version.substr(10, 2)
  const seconds = version.substr(12, 2)

  return Date.UTC(year, month, date, hours, minutes, seconds)
}

function migrationDir(fileName = '') {
  return path.resolve(process.cwd(), 'migrations', fileName)
}

module.exports = class ESMigrate {
  static get CONFIG_FILENAME() { return 'es-migrate.config.js' }
  static get VALID_COMMANDS() { return ['create', 'sync', 'version'] }

  async run(argv) {
    const input = Array.isArray(argv) ? minimist(argv) : minimist(argv.split(' ').slice(1))

    if (input._.length === 0) {
      console.log(`
Usage:
  $ es-migrate [create|sync|version] [name|version] [-d]

\`create\` will make a new migration.
\`sync\` will sync to the specified version (if none is given, latest).
\`sync -d\` will do a dry run of the sync, running the migration but not adding it to the migrations table (useful for testing)
\`version\` will get the current version.
\`version -1\` will get the previous version (-2 will get 2 versions ago, etc.)
`)
      return
    }

    if (ESMigrate.VALID_COMMANDS.indexOf(input._[0]) === -1) {
      console.error(`Command ${input._[0]} not recognized. Use create, sync, or version.`)
      return
    }

    try {
      this.strategy = require(path.resolve(process.cwd(), ESMigrate.CONFIG_FILENAME))
    } catch (err) {
      console.error('Couldn\'t read your config file at ./es-migrate.config.js', err)
      return
    }

    await this.strategy.init()
    await this[input._[0]](input)
    await this.strategy.end()
  }

  get _migrationFiles() { // eslint-disable-line class-methods-use-this
    return fs.readdirSync(migrationDir())
      .filter(fileName => /^\d{14}\-\S+\.js$/.test(fileName))
  }

  _updateVersionInConfig(version) { // eslint-disable-line class-methods-use-this
    const configFilename = path.resolve(process.cwd(), ESMigrate.CONFIG_FILENAME)
    let configFileContents = fs.readFileSync(configFilename, 'utf8')

    // Remove version if it exists
    if (this.strategy.version) {
      const lines = configFileContents.split('\n')
      configFileContents = lines
        .slice(0, lines.length - 4)
        .join('\n')
    }

    fs.writeFileSync(configFilename, `${configFileContents}
// --- BELOW AUTOMATICALLY GENERATED BY ES-MIGRATE ---
// The version of the db this commit depends on
module.exports.version = '${version}'
`)
    this.strategy.version = version
  }

  _up(input) {
    const targetVersion = input._[1]
    const tsFromTargetVersion = targetVersion && tsFromVersion(targetVersion)

    return this._migrationFiles
      .map(async migrationFile => {
        const migration = require(migrationDir(migrationFile))
        migration.version = migrationFile.split('.')[0]

        if (targetVersion && tsFromVersion(migration.version) > tsFromTargetVersion) return Promise.resolve()
        if (await this.strategy.hasRan(migration)) return Promise.resolve()

        input.d ?
          console.log(`Dry running ${migration.version}`) :
          console.log(`Running ${migration.version}`)
        return this.strategy.up(migration, input.d)
      })
      // Run promises in sequence
      .reduce((prev, curr) => prev.then(() => curr), Promise.resolve())
  }

  _down(input) {
    if (!input._[1]) return

    const targetVersion = input._[1]
    const tsFromTargetVersion = targetVersion && tsFromVersion(targetVersion)

    return this._migrationFiles.reverse()
      .map(async migrationFile => {
        const migration = require(migrationDir(migrationFile))
        migration.version = migrationFile.split('.')[0]

        if (targetVersion && tsFromVersion(migration.version) <= tsFromTargetVersion) return Promise.resolve()
        if (!(await this.strategy.hasRan(migration))) return Promise.resolve()

        input.d ?
          console.log(`Dry rolling back ${migration.version}`) :
          console.log(`Rolling back ${migration.version}`)
        return this.strategy.down(migration, input.d)
      })
      // Run promises in sequence
      .reduce((prev, curr) => prev.then(() => curr), Promise.resolve())
  }

  async create(input) {
    if (!input._[1]) {
      console.error('You need to specify a name for the migration')
      return
    }

    const date = new Date()

    const versionName = '' +
      date.getUTCFullYear() +
      zeroPad((date.getUTCMonth() + 1), 2) +
      zeroPad(date.getUTCDate(), 2) +
      zeroPad(date.getUTCHours(), 2) +
      zeroPad(date.getUTCMinutes(), 2) +
      zeroPad(date.getUTCSeconds(), 2) +
      `-${input._[1]}`

    fs.writeFileSync(
      migrationDir(`${versionName}.js`),
      this.strategy.template
    )

    this._updateVersionInConfig(versionName)

    console.log(`Created migrations/${versionName}.js`)
  }

  async sync(input) {
    await this._up(input)
    await this._down(input)
  }

  async version() {
    let i = this._migrationFiles.length - 1
    if (i === -1) return console.error('Couldn\'t get version: no migrations exist yet')

    const toSubtract = process.argv && process.argv[3] && parseInt(process.argv[3].substr(1))
    if (toSubtract && i - toSubtract < 0) return console.error(`Couldn\'t get version: there are only ${this._migrationFiles.length} migrations`)

    if (toSubtract) i -= toSubtract

    console.log(this._migrationFiles[i].split('.')[0])
  }
}
