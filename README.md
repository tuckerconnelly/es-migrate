es-migrate
==========

Minimalistic database-agnostic declarative es6 migrations.

```
npm -g i es-migrate
npm -D i es-migrate
```

```
es-migrate

Usage:
  $ es-migrate [create|sync|version|set] [name|version] [-d]

`create [name]` will make a new migration and set the version in the config file
`sync` will sync to the version in the config file
`sync -d` will do a dry run of the sync, running the migration but not adding it to the migrations table (useful for testing)
`version` will get the current version
`version -1` will get the previous version (-2 will get 2 versions ago, etc.)
`set [version]` will set the version in the config file to the specified version
```

## Philosophy

- Each commit of your code should be *declaratively* associated with a version of your database
- Syncing your database to your code should be as easy as `es-migrate sync`
- Configuration should programmatic so you can use an existing config file or library
- It should be easy to plug in a new database strategy
- It should keep up to date with the latest ES features

## Usage

`es-migrate` reads a config file at `{cwd}/es-migrate.config.js`.  Create a file there:

```js
const { PGStrategy } = require('es-migrate')

const connectionString = process.env.DB_STRING ||
  'postgres://username:password@localhost/dbname'

module.exports = new PGStrategy(connectionString)
```

Then you can:

```
es-migrate create my-migration
es-migrate sync
```

Then if you wanted to run es-migrate against a different database, you could:

```
DB_STRING=postgres://u:p@localhost/test es-migrate sync
```

## Config file

The bottom of the config file is automatically generated by es-migrate on 'create' and 'set':

```
// --- BELOW AUTOMATICALLY GENERATED BY ES-MIGRATE ---
// The version of the db this commit depends on
module.exports.version = '19920524010205-version-p-test-3'
```

This is to associate this particular commit of your repo to a particular version of the database.

## Using with other databases

If you want to connect to another database like MongoDB, you'll need to write a custom strategy:

```js
export default class MyStrategy {
  get template() {
    return `export default {
  async up(client) {

  },

  async down(client) {

  },
}
`
  }

  async init() {
    // Create database connection and initializes migrations table if it doesn't exist
  }

  async hasRan(migration) {
    // returns true if the passed migration has run, false if not
  }

  async up(migration, dry) {
    await migration.up()
    // If not dry, then tell the database the migration has run
  }

  async down(migration, dry) {
    await migration.down()
    // If not dry, then delete the migration from the database
  }

  async end() {
    // Clean up the database connection
  }
}
```

See the `strategies/` folder for examples.

Will gladly accept PRs for additional strategies :)

## License
MIT
